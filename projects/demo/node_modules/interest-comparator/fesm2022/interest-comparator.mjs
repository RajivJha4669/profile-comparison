import * as i0 from '@angular/core';
import { Injectable, EventEmitter, ViewChild, Output, Input, Component } from '@angular/core';
import * as i3 from '@angular/common';
import { CommonModule } from '@angular/common';
import { Navigation, Pagination } from 'swiper/modules';
import { of, from, firstValueFrom, Subject } from 'rxjs';
import Swiper from 'swiper';
import 'swiper/css';
import 'swiper/css/navigation';
import 'swiper/css/pagination';
import * as i1 from '@angular/common/http';
import { HttpHeaders } from '@angular/common/http';
import { timeout, catchError, map } from 'rxjs/operators';

// similarity.service.ts
class SimilarityService {
    http;
    apiUrl = 'https://api.api-ninjas.com/v1/textsimilarity';
    apiKey = '46ZRfGqxZ6v+Q5rG+mA3iQ==FwYzYB5gU69IPZxk';
    constructor(http) {
        this.http = http;
    }
    // Method to set API key from environment
    setApiKey(key) {
        this.apiKey = key;
    }
    async orderInterests(user1Interests, user2Interests, user3Interests = []) {
        try {
            console.log('🔄 Starting interest ordering with API calls...');
            // Combine all interests for comparison
            const allInterests = [...user1Interests, ...user2Interests, ...user3Interests];
            // Build similarity matrix using API calls (limited to avoid too many calls)
            console.log('📊 Building similarity matrix with API...');
            const similarityMatrix = await this.buildSimilarityMatrixOptimized(allInterests);
            // Order interests based on the design rules using API results
            const orderedUser1Interests = this.orderUser1Interests(user1Interests, user2Interests, user3Interests, allInterests, similarityMatrix);
            const orderedUser2Interests = this.orderUser2Interests(user2Interests, user1Interests, user3Interests, allInterests, similarityMatrix);
            console.log('✅ Interest ordering complete using API');
            return {
                user1Interests,
                user2Interests,
                similarityMatrix,
                orderedUser1Interests,
                orderedUser2Interests
            };
        }
        catch (error) {
            console.warn('Similarity API failed, using fallback ordering:', error);
            // Fallback to original order if API fails
            return {
                user1Interests,
                user2Interests,
                similarityMatrix: [],
                orderedUser1Interests: user1Interests,
                orderedUser2Interests: user2Interests
            };
        }
    }
    async buildSimilarityMatrixOptimized(interests) {
        const matrix = [];
        const maxComparisons = 20; // Limit API calls to prevent rate limiting
        let comparisonCount = 0;
        for (let i = 0; i < interests.length; i++) {
            matrix[i] = [];
            for (let j = 0; j < interests.length; j++) {
                if (i === j) {
                    matrix[i][j] = 1; // Same item
                }
                else if (j < i) {
                    matrix[i][j] = matrix[j][i]; // Use cached value
                }
                else {
                    if (comparisonCount < maxComparisons) {
                        try {
                            matrix[i][j] = await this.getSimilarityScore(interests[i], interests[j]);
                            comparisonCount++;
                        }
                        catch (error) {
                            console.warn(`API call failed for comparison ${i}-${j}, using fallback`);
                            matrix[i][j] = this.calculateFallbackSimilarity(interests[i], interests[j]);
                        }
                    }
                    else {
                        // Use fallback for remaining comparisons
                        matrix[i][j] = this.calculateFallbackSimilarity(interests[i], interests[j]);
                    }
                }
            }
        }
        console.log(`📊 Built similarity matrix with ${comparisonCount} API calls`);
        return matrix;
    }
    orderUser1Interests(user1Interests, user2Interests, user3Interests, allInterests, matrix) {
        if (matrix.length === 0) {
            return this.orderUser1InterestsFallback(user1Interests, user2Interests, user3Interests);
        }
        const interestScores = user1Interests.map(interest => {
            const index = allInterests.indexOf(interest);
            if (index === -1)
                return { interest, score: 0 };
            let totalScore = 0;
            let scoreCount = 0;
            // Rule 1: User 3's Influence - If User 3 also has that interest, put it closer to the top
            if (user3Interests.includes(interest)) {
                totalScore += 0.8; // High score for User 3 match
                scoreCount++;
            }
            // Rule 2: User 1's Own Similarity - The more similar User 1's interests are to their own interests, the closer they should be
            for (const otherInterest of user1Interests) {
                if (otherInterest !== interest) {
                    const otherIndex = allInterests.indexOf(otherInterest);
                    if (otherIndex !== -1) {
                        totalScore += matrix[index][otherIndex] * 0.6; // Medium weight for self-similarity
                        scoreCount++;
                    }
                }
            }
            // Rule 3: User 1 vs User 2 Similarity - The more similar User 1's interests are to User 2's interests, the closer they should be
            for (const user2Interest of user2Interests) {
                const user2Index = allInterests.indexOf(user2Interest);
                if (user2Index !== -1) {
                    totalScore += matrix[index][user2Index] * 0.4; // Lower weight for cross-user similarity
                    scoreCount++;
                }
            }
            const avgScore = scoreCount > 0 ? totalScore / scoreCount : 0;
            return { interest, score: avgScore };
        });
        // Sort by similarity score (highest first)
        return interestScores
            .sort((a, b) => b.score - a.score)
            .map(item => item.interest);
    }
    orderUser2Interests(user2Interests, user1Interests, user3Interests, allInterests, matrix) {
        if (matrix.length === 0) {
            return this.orderUser2InterestsFallback(user2Interests, user1Interests, user3Interests);
        }
        const interestScores = user2Interests.map(interest => {
            const index = allInterests.indexOf(interest);
            if (index === -1)
                return { interest, score: 0 };
            let totalScore = 0;
            let scoreCount = 0;
            // Rule 1: User 3's Influence - If User 3 also has that interest, put it closer to the top
            if (user3Interests.includes(interest)) {
                totalScore += 0.8; // High score for User 3 match
                scoreCount++;
            }
            // Rule 2: User 2's Own Similarity - The more similar User 2's interests are to their own interests, the closer they should be
            for (const otherInterest of user2Interests) {
                if (otherInterest !== interest) {
                    const otherIndex = allInterests.indexOf(otherInterest);
                    if (otherIndex !== -1) {
                        totalScore += matrix[index][otherIndex] * 0.6; // Medium weight for self-similarity
                        scoreCount++;
                    }
                }
            }
            // Rule 3: User 2 vs User 1 Similarity - The more similar User 2's interests are to User 1's interests, the closer they should be
            for (const user1Interest of user1Interests) {
                const user1Index = allInterests.indexOf(user1Interest);
                if (user1Index !== -1) {
                    totalScore += matrix[index][user1Index] * 0.4; // Lower weight for cross-user similarity
                    scoreCount++;
                }
            }
            const avgScore = scoreCount > 0 ? totalScore / scoreCount : 0;
            return { interest, score: avgScore };
        });
        // Sort by similarity score (highest first)
        return interestScores
            .sort((a, b) => b.score - a.score)
            .map(item => item.interest);
    }
    orderUser1InterestsFallback(user1Interests, user2Interests, user3Interests) {
        const interestScores = user1Interests.map(interest => {
            let totalScore = 0;
            let scoreCount = 0;
            // Rule 1: User 3's Influence - If User 3 also has that interest, put it closer to the top
            if (user3Interests.includes(interest)) {
                totalScore += 0.8; // High score for User 3 match
                scoreCount++;
            }
            // Rule 2: User 1's Own Similarity - Check for similar interests within User 1
            for (const otherInterest of user1Interests) {
                if (otherInterest !== interest) {
                    const similarity = this.calculateFallbackSimilarity(interest, otherInterest);
                    totalScore += similarity * 0.6; // Medium weight for self-similarity
                    scoreCount++;
                }
            }
            // Rule 3: User 1 vs User 2 Similarity - Check similarity with User 2's interests
            for (const user2Interest of user2Interests) {
                const similarity = this.calculateFallbackSimilarity(interest, user2Interest);
                totalScore += similarity * 0.4; // Lower weight for cross-user similarity
                scoreCount++;
            }
            const avgScore = scoreCount > 0 ? totalScore / scoreCount : 0;
            return { interest, score: avgScore };
        });
        // Sort by similarity score (highest first)
        return interestScores
            .sort((a, b) => b.score - a.score)
            .map(item => item.interest);
    }
    orderUser2InterestsFallback(user2Interests, user1Interests, user3Interests) {
        const interestScores = user2Interests.map(interest => {
            let totalScore = 0;
            let scoreCount = 0;
            // Rule 1: User 3's Influence - If User 3 also has that interest, put it closer to the top
            if (user3Interests.includes(interest)) {
                totalScore += 0.8; // High score for User 3 match
                scoreCount++;
            }
            // Rule 2: User 2's Own Similarity - Check for similar interests within User 2
            for (const otherInterest of user2Interests) {
                if (otherInterest !== interest) {
                    const similarity = this.calculateFallbackSimilarity(interest, otherInterest);
                    totalScore += similarity * 0.6; // Medium weight for self-similarity
                    scoreCount++;
                }
            }
            // Rule 3: User 2 vs User 1 Similarity - Check similarity with User 1's interests
            for (const user1Interest of user1Interests) {
                const similarity = this.calculateFallbackSimilarity(interest, user1Interest);
                totalScore += similarity * 0.4; // Lower weight for cross-user similarity
                scoreCount++;
            }
            const avgScore = scoreCount > 0 ? totalScore / scoreCount : 0;
            return { interest, score: avgScore };
        });
        // Sort by similarity score (highest first)
        return interestScores
            .sort((a, b) => b.score - a.score)
            .map(item => item.interest);
    }
    async buildSimilarityMatrix(interests) {
        const matrix = [];
        for (let i = 0; i < interests.length; i++) {
            matrix[i] = [];
            for (let j = 0; j < interests.length; j++) {
                if (i === j) {
                    matrix[i][j] = 1; // Same item
                }
                else if (j < i) {
                    matrix[i][j] = matrix[j][i]; // Use cached value
                }
                else {
                    matrix[i][j] = await this.getSimilarityScore(interests[i], interests[j]);
                }
            }
        }
        return matrix;
    }
    async getSimilarityScore(text1, text2) {
        try {
            const headers = new HttpHeaders({
                'X-Api-Key': this.apiKey,
                'Content-Type': 'application/json'
            });
            const response = await this.http.post(this.apiUrl, { text_1: text1, text_2: text2 }, { headers }).pipe(timeout(3000), // 3 second timeout
            catchError(error => {
                console.warn(`Similarity API error for "${text1}" vs "${text2}":`, error);
                return of({ similarity: this.calculateFallbackSimilarity(text1, text2) });
            })).toPromise();
            return response?.similarity ?? this.calculateFallbackSimilarity(text1, text2);
        }
        catch (error) {
            console.warn(`Similarity API failed for "${text1}" vs "${text2}":`, error);
            return this.calculateFallbackSimilarity(text1, text2);
        }
    }
    calculateFallbackSimilarity(text1, text2) {
        // Simple fallback similarity calculation based on string similarity
        const normalized1 = text1.toLowerCase().trim();
        const normalized2 = text2.toLowerCase().trim();
        if (normalized1 === normalized2)
            return 1;
        // Check for partial matches
        if (normalized1.includes(normalized2) || normalized2.includes(normalized1)) {
            return 0.7;
        }
        // Check for common words
        const words1 = normalized1.split(/\s+/);
        const words2 = normalized2.split(/\s+/);
        const commonWords = words1.filter(word => words2.includes(word));
        if (commonWords.length > 0) {
            return Math.min(0.5, commonWords.length / Math.max(words1.length, words2.length));
        }
        return 0.1; // Default low similarity
    }
    // Method to get similarity between two specific interests
    getInterestSimilarity(interest1, interest2) {
        return from(this.getSimilarityScore(interest1, interest2)).pipe(catchError(error => {
            console.warn(`Error getting similarity for "${interest1}" vs "${interest2}":`, error);
            return of(this.calculateFallbackSimilarity(interest1, interest2));
        }));
    }
    // Method to find shared interests (similarity >= 0.8)
    findSharedInterests(user1Interests, user2Interests) {
        console.log('🔍 Finding shared interests with API calls...');
        // Create an array of promises for similarity checks
        const similarityChecks = user1Interests.flatMap(interest1 => user2Interests.map(interest2 => this.getInterestSimilarity(interest1, interest2).toPromise()
            .then(similarity => ({ interest1, interest2, similarity: similarity ?? 0 }))));
        return from(Promise.all(similarityChecks)).pipe(map(results => {
            const shared = [];
            for (const result of results) {
                if (result.similarity >= 0.8) {
                    // Use User 2's interest as the shared interest (as per design)
                    if (!shared.includes(result.interest2)) {
                        shared.push(result.interest2);
                    }
                }
            }
            console.log('✅ Shared interests found:', shared);
            return shared.slice(0, 2); // Limit to 2 shared interests for display
        }), catchError(error => {
            console.warn('Error finding shared interests:', error);
            return of(this.findSharedInterestsFallback(user1Interests, user2Interests));
        }));
    }
    findSharedInterestsFallback(user1Interests, user2Interests) {
        const shared = [];
        for (const interest1 of user1Interests) {
            for (const interest2 of user2Interests) {
                if (this.calculateFallbackSimilarity(interest1, interest2) >= 0.8) {
                    if (!shared.includes(interest2)) {
                        shared.push(interest2);
                    }
                }
            }
        }
        return shared.slice(0, 2);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.14", ngImport: i0, type: SimilarityService, deps: [{ token: i1.HttpClient }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.14", ngImport: i0, type: SimilarityService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.14", ngImport: i0, type: SimilarityService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: () => [{ type: i1.HttpClient }] });

class FaceDetectService {
    http;
    apiUrl = 'https://api.api-ninjas.com/v1/facedetect';
    apiKey = '46ZRfGqxZ6v+Q5rG+mA3iQ==FwYzYB5gU69IPZxk';
    constructor(http) {
        this.http = http;
    }
    setApiKey(key) {
        this.apiKey = key;
    }
    // Detect faces in an image file
    detectFaces(imageFile) {
        console.log('🔍 Starting face detection for file:', {
            name: imageFile.name,
            size: imageFile.size,
            type: imageFile.type
        });
        const formData = new FormData();
        formData.append('image', imageFile);
        // Don't set Content-Type header - let Angular handle it for FormData
        const headers = new HttpHeaders({
            'X-Api-Key': this.apiKey
            // Removed Accept header to let the API respond with its default format
        });
        console.log('📡 Sending request to API:', this.apiUrl);
        console.log('🔑 Using API key:', this.apiKey ? 'Present' : 'Missing');
        return this.http.post(this.apiUrl, formData, { headers }).pipe(timeout(15000), map(response => {
            console.log('✅ Face detection API response:', response);
            // Handle different response formats
            let faces = [];
            if (Array.isArray(response)) {
                faces = response;
            }
            else if (response && Array.isArray(response.faces)) {
                faces = response.faces;
            }
            else if (response && typeof response === 'object') {
                console.warn('⚠️ Unexpected response format:', response);
                faces = [];
            }
            return {
                faces: faces,
                success: true,
                source: 'api-ninjas'
            };
        }), catchError(error => {
            console.error('❌ Face detection API error:', error);
            console.error('Error details:', {
                status: error.status,
                message: error.message,
                error: error.error
            });
            return of({
                faces: [],
                success: false,
                error: `API Error: ${error.status || 'Unknown'} - ${error.message || error.error?.error || 'Face detection failed'}`,
                source: 'error'
            });
        }));
    }
    // Detect faces from an image URL
    async detectFacesFromUrl(imageUrl) {
        console.log('🌐 Starting face detection from URL:', imageUrl);
        try {
            // First validate the image URL
            console.log('✅ Step 1: Validating image URL...');
            const isValidImage = await this.validateProfileImage(imageUrl);
            if (!isValidImage) {
                console.warn('❌ Image validation failed');
                return {
                    faces: [],
                    success: false,
                    error: 'Invalid image URL or image cannot be loaded',
                    source: 'validation'
                };
            }
            console.log('✅ Image validation passed');
            // Fetch the image with better error handling
            console.log('📥 Step 2: Fetching image...');
            let response;
            try {
                response = await fetch(imageUrl, {
                    mode: 'cors',
                    headers: {
                        'Accept': 'image/*',
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                    }
                });
                console.log('✅ CORS fetch successful');
            }
            catch (fetchError) {
                console.warn('⚠️ CORS fetch failed, trying no-cors mode:', fetchError);
                try {
                    response = await fetch(imageUrl, {
                        mode: 'no-cors'
                    });
                    console.log('✅ No-CORS fetch successful');
                }
                catch (noCorsError) {
                    throw new Error(`Failed to fetch image with both CORS modes: ${fetchError}, ${noCorsError}`);
                }
            }
            if (!response.ok) {
                throw new Error(`Failed to fetch image: ${response.status} ${response.statusText}`);
            }
            console.log('📄 Step 3: Converting to blob...');
            const blob = await response.blob();
            console.log('📊 Blob info:', {
                type: blob.type,
                size: blob.size,
                sizeKB: Math.round(blob.size / 1024)
            });
            // Validate blob type
            if (blob.type && !blob.type.startsWith('image/')) {
                throw new Error(`Invalid content type: ${blob.type}. Expected image.`);
            }
            const file = new File([blob], 'profile.jpg', { type: blob.type || 'image/jpeg' });
            // Validate file size (API might have limits)
            if (file.size > 10 * 1024 * 1024) { // 10MB limit
                throw new Error('Image file too large. Maximum size is 10MB.');
            }
            console.log('🚀 Step 4: Sending to face detection API...');
            console.log(`📎 File details: ${file.name}, size: ${file.size} bytes, type: ${file.type}`);
            // Try face detection
            const result = await firstValueFrom(this.detectFaces(file));
            console.log('🎯 Face detection result:', result);
            return result || {
                faces: [],
                success: false,
                error: 'No result from face detection',
                source: 'unknown'
            };
        }
        catch (error) {
            console.error('💥 Face detection from URL failed:', error);
            return {
                faces: [],
                success: false,
                error: error instanceof Error ? error.message : 'Unknown error',
                source: 'error'
            };
        }
    }
    // Enhanced image validation with better error handling
    validateProfileImage(imageUrl) {
        return new Promise((resolve) => {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            const timeoutId = setTimeout(() => {
                resolve(false);
            }, 10000); // 10 second timeout
            img.onload = () => {
                clearTimeout(timeoutId);
                // Check if image has reasonable dimensions
                if (img.width < 50 || img.height < 50) {
                    resolve(false);
                }
                else {
                    resolve(true);
                }
            };
            img.onerror = () => {
                clearTimeout(timeoutId);
                resolve(false);
            };
            img.src = imageUrl;
        });
    }
    // Get API status for debugging
    getApiStatus() {
        return {
            available: true,
            hasKey: !!this.apiKey
        };
    }
    // Quick API connectivity test
    async testApiQuick() {
        try {
            console.log('🧪 Quick API test starting...');
            // Test with minimal payload
            const response = await fetch(this.apiUrl, {
                method: 'POST',
                headers: {
                    'X-Api-Key': this.apiKey,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({})
            });
            const responseText = await response.text();
            console.log('🧪 Quick test response:', { status: response.status, text: responseText });
            return {
                success: response.status !== 401 && response.status !== 403,
                message: `API responded with status ${response.status}`,
                details: {
                    status: response.status,
                    statusText: response.statusText,
                    response: responseText
                }
            };
        }
        catch (error) {
            console.error('🧪 Quick API test failed:', error);
            return {
                success: false,
                message: error instanceof Error ? error.message : 'Unknown test error'
            };
        }
    }
    // Test method to verify API connectivity
    async testApiConnection() {
        try {
            // Create a small test image (1x1 pixel PNG)
            const canvas = document.createElement('canvas');
            canvas.width = 100;
            canvas.height = 100;
            const ctx = canvas.getContext('2d');
            if (ctx) {
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(0, 0, 100, 100);
            }
            return new Promise((resolve) => {
                canvas.toBlob(async (blob) => {
                    if (!blob) {
                        resolve({ success: false, message: 'Failed to create test image' });
                        return;
                    }
                    const testFile = new File([blob], 'test.png', { type: 'image/png' });
                    console.log('Testing API with file:', testFile.name, testFile.size, testFile.type);
                    try {
                        const result = await firstValueFrom(this.detectFaces(testFile));
                        resolve({
                            success: result.success,
                            message: result.success ? 'API is working correctly' : (result.error || 'API test failed')
                        });
                    }
                    catch (error) {
                        resolve({
                            success: false,
                            message: error instanceof Error ? error.message : 'Unknown API test error'
                        });
                    }
                }, 'image/png');
            });
        }
        catch (error) {
            return {
                success: false,
                message: error instanceof Error ? error.message : 'Failed to create test image'
            };
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.14", ngImport: i0, type: FaceDetectService, deps: [{ token: i1.HttpClient }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.14", ngImport: i0, type: FaceDetectService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.14", ngImport: i0, type: FaceDetectService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: () => [{ type: i1.HttpClient }] });

class InterestComparatorComponent {
    similarityService;
    faceAlignService;
    user1;
    user2;
    user3;
    apiKey;
    similarityThreshold = 0.8; // Configurable similarity threshold
    viewProfile = new EventEmitter();
    comparatorContainer;
    swiperContainer;
    orderedUser1Interests = [];
    orderedUser2Interests = [];
    sharedInterests = [];
    isLoading = true;
    apiError = false;
    similarityMatrix = [];
    allInterests = [];
    additionalSlides = [];
    // Face detection results
    user1Faces = [];
    user2Faces = [];
    showFaceDetectionResults = false;
    loadingMessage = 'Initializing...';
    swiper;
    destroy$ = new Subject();
    constructor(similarityService, faceAlignService) {
        this.similarityService = similarityService;
        this.faceAlignService = faceAlignService;
    }
    ngOnInit() {
        console.log('🚀 Interest Comparator Component Initializing...');
        // Set API key if provided
        if (this.apiKey) {
            this.faceAlignService.setApiKey(this.apiKey);
            this.similarityService.setApiKey(this.apiKey);
            console.log('✅ API key configured');
        }
        else {
            console.warn('⚠️ No API key provided, using fallback mode');
        }
        this.initializeComponent();
    }
    ngAfterViewInit() {
        this.initializeSwiper();
    }
    ngOnDestroy() {
        if (this.swiper) {
            this.swiper.destroy();
        }
        this.destroy$.next();
        this.destroy$.complete();
    }
    initializeSwiper() {
        if (this.swiperContainer) {
            try {
                console.log('🔄 Initializing Swiper...');
                this.swiper = new Swiper(this.swiperContainer.nativeElement, {
                    modules: [Navigation, Pagination],
                    direction: 'horizontal',
                    loop: false,
                    pagination: {
                        el: '.swiper-pagination',
                        clickable: true,
                    },
                    spaceBetween: 28,
                    slidesPerView: 1,
                    allowTouchMove: true,
                    resistance: true,
                    resistanceRatio: 0.85,
                    speed: 300,
                    on: {
                        init: (swiper) => {
                            console.log('✅ Swiper initialized successfully');
                        },
                        slideChange: (swiper) => {
                            console.log('📱 Slide changed to:', swiper.activeIndex);
                        }
                    }
                });
                console.log('✅ Swiper setup complete');
            }
            catch (error) {
                console.error('❌ Swiper initialization failed:', error);
                this.swiper = undefined;
            }
        }
        else {
            console.warn('⚠️ Swiper container not found');
        }
    }
    async initializeComponent() {
        try {
            this.isLoading = true;
            this.apiError = false;
            this.loadingMessage = 'Processing interests...';
            console.log('🚀 Starting component initialization...');
            console.log('👤 User 1:', this.user1.name, 'Interests:', this.user1.interests);
            console.log('👤 User 2:', this.user2.name, 'Interests:', this.user2.interests);
            if (this.user3) {
                console.log('👤 User 3:', this.user3.name, 'Interests:', this.user3.interests);
            }
            // Step 1: Process interests with similarity analysis
            console.log('📊 Step 1: Processing interest similarity...');
            const similarityResult = await this.similarityService.orderInterests(this.user1.interests, this.user2.interests, this.user3?.interests || []);
            this.orderedUser1Interests = similarityResult.orderedUser1Interests;
            this.orderedUser2Interests = similarityResult.orderedUser2Interests;
            this.similarityMatrix = similarityResult.similarityMatrix;
            this.allInterests = [...this.user1.interests, ...this.user2.interests, ...(this.user3?.interests || [])];
            console.log('✅ Interest ordering complete');
            console.log('📋 Ordered User 1 interests:', this.orderedUser1Interests);
            console.log('📋 Ordered User 2 interests:', this.orderedUser2Interests);
            // Step 2: Find shared interests using configurable threshold
            console.log('🔍 Step 2: Finding shared interests with threshold:', this.similarityThreshold);
            this.sharedInterests = await this.findSharedInterests();
            console.log('✅ Shared interests found:', this.sharedInterests);
            // Step 3: Create additional slides for overflow content
            this.createAdditionalSlides();
            // Step 4: Process face detection for both users (non-blocking)
            this.loadingMessage = 'Detecting faces...';
            console.log('📸 Step 3: Processing face detection...');
            // Use Promise.race to timeout face detection after 10 seconds
            const faceDetectionPromise = this.processFaceDetection();
            const timeoutPromise = new Promise(resolve => setTimeout(resolve, 10000));
            try {
                await Promise.race([faceDetectionPromise, timeoutPromise]);
                console.log('✅ Face detection completed (or timed out)');
            }
            catch (error) {
                console.warn('⚠️ Face detection failed or timed out:', error);
            }
            // Show face detection results if available
            if (this.user1Faces.length > 0 || this.user2Faces.length > 0) {
                this.showFaceDetectionResults = true;
                console.log('✅ Face detection results available');
            }
            else {
                console.log('⚠️ No face detection results available');
            }
        }
        catch (error) {
            console.error('❌ Error initializing component:', error);
            this.apiError = true;
            // Fallback to original order
            this.orderedUser1Interests = this.user1.interests;
            this.orderedUser2Interests = this.user2.interests;
            this.sharedInterests = this.findSharedInterestsFallback();
            this.createAdditionalSlides();
        }
        finally {
            this.isLoading = false;
            console.log('✅ Component initialization complete');
        }
    }
    createAdditionalSlides() {
        this.additionalSlides = [];
        // Create slides for additional interests if there are too many
        const allInterests = [...this.orderedUser1Interests, ...this.orderedUser2Interests];
        const maxInterestsPerSlide = 6;
        for (let i = 0; i < allInterests.length; i += maxInterestsPerSlide) {
            const slideInterests = allInterests.slice(i, i + maxInterestsPerSlide);
            if (slideInterests.length > 0) {
                this.additionalSlides.push({ interests: slideInterests });
            }
        }
        console.log('📱 Created', this.additionalSlides.length, 'additional slides');
    }
    async processFaceDetection() {
        try {
            console.log('🔍 Starting face detection process...');
            // Process User 1 face detection with timeout
            console.log('👤 Processing User 1 face detection:', this.user1.image);
            try {
                const user1Result = await Promise.race([
                    this.faceAlignService.detectFacesFromUrl(this.user1.image),
                    new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 5000))
                ]);
                this.user1Faces = user1Result.faces || [];
                console.log('✅ User 1 face detection result:', user1Result.success ? `${this.user1Faces.length} faces found` : user1Result.error);
                console.log('👤 User 1 faces:', this.user1Faces);
            }
            catch (error) {
                console.warn('❌ User 1 face detection failed:', error);
                this.user1Faces = [];
            }
            // Process User 2 face detection with timeout
            console.log('👤 Processing User 2 face detection:', this.user2.image);
            try {
                const user2Result = await Promise.race([
                    this.faceAlignService.detectFacesFromUrl(this.user2.image),
                    new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 5000))
                ]);
                this.user2Faces = user2Result.faces || [];
                console.log('✅ User 2 face detection result:', user2Result.success ? `${this.user2Faces.length} faces found` : user2Result.error);
                console.log('👤 User 2 faces:', this.user2Faces);
            }
            catch (error) {
                console.warn('❌ User 2 face detection failed:', error);
                this.user2Faces = [];
            }
            // Store face data for potential future use (eye-to-eye alignment)
            if (this.user1Faces.length > 0 || this.user2Faces.length > 0) {
                this.user1.faceData = this.user1Faces;
                this.user2.faceData = this.user2Faces;
                console.log('💾 Face data stored for users');
            }
        }
        catch (error) {
            console.error('💥 Face detection process failed:', error);
            // Don't throw error, just log it
        }
    }
    async findSharedInterests() {
        try {
            // Use the configurable similarity threshold
            const shared = await this.similarityService.findSharedInterests(this.user1.interests, this.user2.interests).toPromise();
            // Filter by configurable threshold
            const filteredShared = shared?.filter(interest => {
                // Check if this interest has high similarity with any user2 interest
                return this.user2.interests.some(user2Interest => this.calculateFallbackSimilarity(interest, user2Interest) >= this.similarityThreshold);
            }) || [];
            return filteredShared.slice(0, 2); // Limit to 2 shared interests for display
        }
        catch (error) {
            console.warn('Error finding shared interests:', error);
            return this.findSharedInterestsFallback();
        }
    }
    findSharedInterestsFallback() {
        const shared = [];
        for (const interest1 of this.user1.interests) {
            for (const interest2 of this.user2.interests) {
                if (this.calculateFallbackSimilarity(interest1, interest2) >= this.similarityThreshold) {
                    // Use User 2's interest as the shared interest (as per design)
                    if (!shared.includes(interest2)) {
                        shared.push(interest2);
                    }
                }
            }
        }
        return shared.slice(0, 2);
    }
    calculateFallbackSimilarity(text1, text2) {
        const normalized1 = text1.toLowerCase().trim();
        const normalized2 = text2.toLowerCase().trim();
        if (normalized1 === normalized2)
            return 1;
        if (normalized1.includes(normalized2) || normalized2.includes(normalized1)) {
            return 0.8;
        }
        const words1 = normalized1.split(/\s+/);
        const words2 = normalized2.split(/\s+/);
        const commonWords = words1.filter(word => words2.includes(word));
        if (commonWords.length > 0) {
            return Math.min(0.7, commonWords.length / Math.max(words1.length, words2.length));
        }
        return 0.1;
    }
    isSharedInterest(interest) {
        return this.sharedInterests.includes(interest);
    }
    // Utility methods
    trackByInterest(index, interest) {
        return interest;
    }
    onViewProfile(user) {
        console.log(`🔍 View Profile clicked for: ${user}`);
        this.viewProfile.emit({ user });
        alert('You have been routed to a profile page.');
    }
    // Public method to get face detection results
    getFaceDetectionResults() {
        return {
            user1: {
                faces: this.user1Faces,
                image: this.user1.image
            },
            user2: {
                faces: this.user2Faces,
                image: this.user2.image
            }
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.14", ngImport: i0, type: InterestComparatorComponent, deps: [{ token: SimilarityService }, { token: FaceDetectService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.14", type: InterestComparatorComponent, isStandalone: true, selector: "lib-interest-comparator", inputs: { user1: "user1", user2: "user2", user3: "user3", apiKey: "apiKey", similarityThreshold: "similarityThreshold" }, outputs: { viewProfile: "viewProfile" }, viewQueries: [{ propertyName: "comparatorContainer", first: true, predicate: ["comparatorContainer"], descendants: true }, { propertyName: "swiperContainer", first: true, predicate: ["swiperContainer"], descendants: true }], ngImport: i0, template: `
    <div class="matcher-home"
         [class.loading]="isLoading"
         [class.api-error]="apiError"
         #comparatorContainer>

      <!-- Top Header Section -->
      <div class="top-header">

        <div class="swipe-indicator">
          <div class="swipe-arrows">
            <span class="arrow">←</span>
            <span class="arrow">→</span>
          </div>
        </div>
        <div class="separator-line"></div>
      </div>

      <!-- Main Content Area -->
      <div class="main-content">
        <div class="background-faces">
          <div class="face user1-face" [style.background-image]="'url(' + user1.image + ')'"></div>
          <div class="face user2-face" [style.background-image]="'url(' + user2.image + ')'"></div>
        </div>

        <div class="swiper" #swiperContainer>
          <div class="swiper-wrapper">
            <!-- Main slide with three cards -->
            <div class="swiper-slide">
              <div class="cards-container">
                <!-- User 1 Card (Left) -->
                <div class="user1-card">
                  <div class="card-content">
                    <div *ngFor="let interest of orderedUser1Interests; trackBy: trackByInterest"
                         class="interest-item"
                         [class.shared-interest]="isSharedInterest(interest)">
                      <span class="interest-text">{{ interest }}</span>
                    </div>
                    <div class="view-profile-btn" (click)="onViewProfile('user1')">
                      View Profile
                    </div>
                  </div>
                </div>

                <!-- Shared Interests Card (Middle) -->
                <div class="shared-card" *ngIf="sharedInterests.length > 0">
                  <div class="card-content">
                    <div *ngFor="let shared of sharedInterests; let i = index"
                         class="shared-interest-item"
                         [class.cyan-glow]="i === 0"
                         [class.magenta-glow]="i === 1">
                      <span class="shared-text">{{ shared }}</span>
                    </div>
                  </div>
                </div>

                <!-- User 2 Card (Right) -->
                <div class="user2-card">
                  <div class="card-content">
                    <div *ngFor="let interest of orderedUser2Interests; trackBy: trackByInterest"
                         class="interest-item"
                         [class.shared-interest]="isSharedInterest(interest)">
                      <span class="interest-text">{{ interest }}</span>
                    </div>
                    <div class="view-profile-btn" (click)="onViewProfile('user2')">
                      View Profile
                    </div>
                  </div>
                </div>
              </div>
            </div>

            <!-- Additional slides for overflow content -->
            <div class="swiper-slide" *ngFor="let slide of additionalSlides; let i = index">
              <div class="additional-content">
                <h3>Additional Interests</h3>
                <div class="additional-interests">
                  <div *ngFor="let interest of slide.interests" class="interest-item">
                    <span class="interest-text">{{ interest }}</span>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Swiper pagination -->
          <div class="swiper-pagination"></div>
        </div>
      </div>

      <!-- Loading Overlay -->
      <div *ngIf="isLoading" class="loading-overlay">
        <div class="loading-spinner">
          <div class="spinner-ring"></div>
          <div class="spinner-text">{{ loadingMessage }}</div>
        </div>
      </div>
    </div>
  `, isInline: true, styles: [".matcher-home{width:100%;max-width:400px;height:100vh;margin:0 auto;position:relative;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,sans-serif;overflow:hidden;display:flex;flex-direction:column}.matcher-home.loading{opacity:.7;pointer-events:none}.matcher-home.api-error{border:2px solid #ff6b6b}.top-header{flex:0 0 15%;background:#000c;padding:20px;display:flex;flex-direction:column;gap:15px;z-index:10}.user-labels{display:flex;justify-content:space-between;align-items:center}.user-label{font-size:16px;font-weight:600;color:#fff;text-shadow:0 1px 2px rgba(0,0,0,.3)}.swipe-indicator{min-height:400px;display:flex;align-items:center;justify-content:center;gap:12px}.arrow{font-size:18px;color:#fff;font-weight:700}.separator-line{height:2px;background:red;width:100%;border-radius:1px}.main-content{flex:1;position:relative;overflow:hidden}.background-faces{position:absolute;inset:0;z-index:1}.face{position:absolute;width:200px;height:100%;background-size:cover;background-position:center}.user1-face{left:20px;top:20px}.user2-face{right:20px;top:20px}.swiper{width:100%;height:100%;position:relative;z-index:2}.swiper-slide{display:flex;align-items:center;justify-content:center;padding:20px}.cards-container{display:flex;gap:15px;width:100%;height:100%;align-items:center;justify-content:center}.interest-item{padding:10px 14px}.interest-text{font-size:14px;font-weight:600;color:#fff;word-wrap:break-word;line-height:1.4}.shared-interest-item{padding:12px 16px;text-align:center}.shared-text{font-size:16px;font-weight:700;color:#fff;text-shadow:0 1px 2px rgba(0,0,0,.1)}.view-profile-btn{color:#fff;border:none;padding:10px 16px;font-size:14px;font-weight:800;cursor:pointer;margin-top:auto;text-align:center}.view-profile-btn:disabled{opacity:.6;cursor:not-allowed}.additional-content{text-align:center;color:#fff;width:100%;padding:20px}.additional-content h3{margin-bottom:20px;font-size:18px;font-weight:700}.additional-interests{display:flex;flex-direction:column;gap:10px;align-items:center}.additional-interests .interest-item{max-width:200px}.swiper-pagination{position:absolute;bottom:15px;left:50%;transform:translate(-50%)}// .swiper-pagination-bullet{// background: rgba(255,255,255,.5);// opacity: 1;// width: 8px;// height: 8px;// margin: 0 4px;// transition: all .3s ease;//}// .swiper-pagination-bullet-active{// background: #667eea;// transform: scale(1.2);// box-shadow: 0 0 10px rgba(102,126,234,.5);//}.loading-overlay{position:absolute;inset:0;background:#000c;display:flex;justify-content:center;align-items:center;z-index:100;-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px)}.loading-spinner{text-align:center;color:#fff;background:#ffffff1a;padding:30px;border-radius:20px;-webkit-backdrop-filter:blur(15px);backdrop-filter:blur(15px);border:1px solid rgba(255,255,255,.2)}.spinner-ring{width:50px;height:50px;border:4px solid rgba(255,255,255,.2);border-top:4px solid #667eea;border-radius:50%;animation:spin 1s linear infinite;margin:0 auto 20px;box-shadow:0 0 20px #667eea4d}.spinner-text{color:#fff;font-size:16px;font-weight:600;text-shadow:0 2px 4px rgba(0,0,0,.3)}@keyframes spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.14", ngImport: i0, type: InterestComparatorComponent, decorators: [{
            type: Component,
            args: [{ selector: 'lib-interest-comparator', standalone: true, imports: [CommonModule], template: `
    <div class="matcher-home"
         [class.loading]="isLoading"
         [class.api-error]="apiError"
         #comparatorContainer>

      <!-- Top Header Section -->
      <div class="top-header">

        <div class="swipe-indicator">
          <div class="swipe-arrows">
            <span class="arrow">←</span>
            <span class="arrow">→</span>
          </div>
        </div>
        <div class="separator-line"></div>
      </div>

      <!-- Main Content Area -->
      <div class="main-content">
        <div class="background-faces">
          <div class="face user1-face" [style.background-image]="'url(' + user1.image + ')'"></div>
          <div class="face user2-face" [style.background-image]="'url(' + user2.image + ')'"></div>
        </div>

        <div class="swiper" #swiperContainer>
          <div class="swiper-wrapper">
            <!-- Main slide with three cards -->
            <div class="swiper-slide">
              <div class="cards-container">
                <!-- User 1 Card (Left) -->
                <div class="user1-card">
                  <div class="card-content">
                    <div *ngFor="let interest of orderedUser1Interests; trackBy: trackByInterest"
                         class="interest-item"
                         [class.shared-interest]="isSharedInterest(interest)">
                      <span class="interest-text">{{ interest }}</span>
                    </div>
                    <div class="view-profile-btn" (click)="onViewProfile('user1')">
                      View Profile
                    </div>
                  </div>
                </div>

                <!-- Shared Interests Card (Middle) -->
                <div class="shared-card" *ngIf="sharedInterests.length > 0">
                  <div class="card-content">
                    <div *ngFor="let shared of sharedInterests; let i = index"
                         class="shared-interest-item"
                         [class.cyan-glow]="i === 0"
                         [class.magenta-glow]="i === 1">
                      <span class="shared-text">{{ shared }}</span>
                    </div>
                  </div>
                </div>

                <!-- User 2 Card (Right) -->
                <div class="user2-card">
                  <div class="card-content">
                    <div *ngFor="let interest of orderedUser2Interests; trackBy: trackByInterest"
                         class="interest-item"
                         [class.shared-interest]="isSharedInterest(interest)">
                      <span class="interest-text">{{ interest }}</span>
                    </div>
                    <div class="view-profile-btn" (click)="onViewProfile('user2')">
                      View Profile
                    </div>
                  </div>
                </div>
              </div>
            </div>

            <!-- Additional slides for overflow content -->
            <div class="swiper-slide" *ngFor="let slide of additionalSlides; let i = index">
              <div class="additional-content">
                <h3>Additional Interests</h3>
                <div class="additional-interests">
                  <div *ngFor="let interest of slide.interests" class="interest-item">
                    <span class="interest-text">{{ interest }}</span>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Swiper pagination -->
          <div class="swiper-pagination"></div>
        </div>
      </div>

      <!-- Loading Overlay -->
      <div *ngIf="isLoading" class="loading-overlay">
        <div class="loading-spinner">
          <div class="spinner-ring"></div>
          <div class="spinner-text">{{ loadingMessage }}</div>
        </div>
      </div>
    </div>
  `, styles: [".matcher-home{width:100%;max-width:400px;height:100vh;margin:0 auto;position:relative;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,sans-serif;overflow:hidden;display:flex;flex-direction:column}.matcher-home.loading{opacity:.7;pointer-events:none}.matcher-home.api-error{border:2px solid #ff6b6b}.top-header{flex:0 0 15%;background:#000c;padding:20px;display:flex;flex-direction:column;gap:15px;z-index:10}.user-labels{display:flex;justify-content:space-between;align-items:center}.user-label{font-size:16px;font-weight:600;color:#fff;text-shadow:0 1px 2px rgba(0,0,0,.3)}.swipe-indicator{min-height:400px;display:flex;align-items:center;justify-content:center;gap:12px}.arrow{font-size:18px;color:#fff;font-weight:700}.separator-line{height:2px;background:red;width:100%;border-radius:1px}.main-content{flex:1;position:relative;overflow:hidden}.background-faces{position:absolute;inset:0;z-index:1}.face{position:absolute;width:200px;height:100%;background-size:cover;background-position:center}.user1-face{left:20px;top:20px}.user2-face{right:20px;top:20px}.swiper{width:100%;height:100%;position:relative;z-index:2}.swiper-slide{display:flex;align-items:center;justify-content:center;padding:20px}.cards-container{display:flex;gap:15px;width:100%;height:100%;align-items:center;justify-content:center}.interest-item{padding:10px 14px}.interest-text{font-size:14px;font-weight:600;color:#fff;word-wrap:break-word;line-height:1.4}.shared-interest-item{padding:12px 16px;text-align:center}.shared-text{font-size:16px;font-weight:700;color:#fff;text-shadow:0 1px 2px rgba(0,0,0,.1)}.view-profile-btn{color:#fff;border:none;padding:10px 16px;font-size:14px;font-weight:800;cursor:pointer;margin-top:auto;text-align:center}.view-profile-btn:disabled{opacity:.6;cursor:not-allowed}.additional-content{text-align:center;color:#fff;width:100%;padding:20px}.additional-content h3{margin-bottom:20px;font-size:18px;font-weight:700}.additional-interests{display:flex;flex-direction:column;gap:10px;align-items:center}.additional-interests .interest-item{max-width:200px}.swiper-pagination{position:absolute;bottom:15px;left:50%;transform:translate(-50%)}// .swiper-pagination-bullet{// background: rgba(255,255,255,.5);// opacity: 1;// width: 8px;// height: 8px;// margin: 0 4px;// transition: all .3s ease;//}// .swiper-pagination-bullet-active{// background: #667eea;// transform: scale(1.2);// box-shadow: 0 0 10px rgba(102,126,234,.5);//}.loading-overlay{position:absolute;inset:0;background:#000c;display:flex;justify-content:center;align-items:center;z-index:100;-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px)}.loading-spinner{text-align:center;color:#fff;background:#ffffff1a;padding:30px;border-radius:20px;-webkit-backdrop-filter:blur(15px);backdrop-filter:blur(15px);border:1px solid rgba(255,255,255,.2)}.spinner-ring{width:50px;height:50px;border:4px solid rgba(255,255,255,.2);border-top:4px solid #667eea;border-radius:50%;animation:spin 1s linear infinite;margin:0 auto 20px;box-shadow:0 0 20px #667eea4d}.spinner-text{color:#fff;font-size:16px;font-weight:600;text-shadow:0 2px 4px rgba(0,0,0,.3)}@keyframes spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}\n"] }]
        }], ctorParameters: () => [{ type: SimilarityService }, { type: FaceDetectService }], propDecorators: { user1: [{
                type: Input
            }], user2: [{
                type: Input
            }], user3: [{
                type: Input
            }], apiKey: [{
                type: Input
            }], similarityThreshold: [{
                type: Input
            }], viewProfile: [{
                type: Output
            }], comparatorContainer: [{
                type: ViewChild,
                args: ['comparatorContainer']
            }], swiperContainer: [{
                type: ViewChild,
                args: ['swiperContainer']
            }] } });

class FaceAlignmentService {
    faceDetectService;
    constructor(faceDetectService) {
        this.faceDetectService = faceDetectService;
    }
    /**
     * Align two user images eye-to-eye for consistent comparison
     */
    async alignUserImages(user1ImageUrl, user2ImageUrl) {
        try {
            console.log('Starting face alignment for two users...');
            // Detect faces in both images
            const [user1Detection, user2Detection] = await Promise.all([
                this.faceDetectService.detectFacesFromUrl(user1ImageUrl),
                this.faceDetectService.detectFacesFromUrl(user2ImageUrl)
            ]);
            // Check if face detection was successful for both users
            if (!user1Detection.success || !user2Detection.success) {
                return {
                    success: false,
                    error: `Face detection failed: User1=${user1Detection.success}, User2=${user2Detection.success}. ` +
                        `Errors: ${user1Detection.error || 'none'}, ${user2Detection.error || 'none'}`
                };
            }
            // Check if faces were found
            if (user1Detection.faces.length === 0 || user2Detection.faces.length === 0) {
                return {
                    success: false,
                    error: `No faces detected: User1=${user1Detection.faces.length} faces, User2=${user2Detection.faces.length} faces`
                };
            }
            // Get the largest face from each image (assuming it's the main subject)
            const user1Face = this.getLargestFace(user1Detection.faces);
            const user2Face = this.getLargestFace(user2Detection.faces);
            // Calculate estimated eye positions
            const user1FaceData = {
                ...user1Face,
                eyeCenter: this.estimateEyeCenter(user1Face)
            };
            const user2FaceData = {
                ...user2Face,
                eyeCenter: this.estimateEyeCenter(user2Face)
            };
            // Load and align the images
            const [user1AlignedImage, user2AlignedImage] = await Promise.all([
                this.alignImageToStandardSize(user1ImageUrl, user1FaceData),
                this.alignImageToStandardSize(user2ImageUrl, user2FaceData)
            ]);
            return {
                success: true,
                user1AlignedImage,
                user2AlignedImage,
                user1FaceData,
                user2FaceData
            };
        }
        catch (error) {
            console.error('Face alignment error:', error);
            return {
                success: false,
                error: error instanceof Error ? error.message : 'Unknown alignment error'
            };
        }
    }
    /**
     * Get the largest face from detected faces (most likely to be the main subject)
     */
    getLargestFace(faces) {
        return faces.reduce((largest, current) => {
            const currentArea = current.width * current.height;
            const largestArea = largest.width * largest.height;
            return currentArea > largestArea ? current : largest;
        });
    }
    /**
     * Estimate eye center position based on face bounding box
     * Eyes are typically located at about 1/3 down from the top of the face
     * and centered horizontally
     */
    estimateEyeCenter(face) {
        return {
            x: face.x + (face.width / 2),
            y: face.y + (face.height * 0.35) // Eyes are roughly 35% down from top of face
        };
    }
    /**
     * Align image to standard size with face centered and eyes at consistent position
     */
    async alignImageToStandardSize(imageUrl, faceData) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => {
                try {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    if (!ctx) {
                        reject(new Error('Failed to get canvas context'));
                        return;
                    }
                    // Standard output size
                    const outputSize = 300;
                    canvas.width = outputSize;
                    canvas.height = outputSize;
                    // Calculate scaling and positioning
                    const scale = outputSize / Math.max(faceData.width, faceData.height) * 0.8; // Scale face to 80% of canvas
                    const scaledFaceWidth = faceData.width * scale;
                    const scaledFaceHeight = faceData.height * scale;
                    // Center the face in the canvas
                    const targetX = (outputSize - scaledFaceWidth) / 2;
                    const targetY = (outputSize - scaledFaceHeight) / 2;
                    // Calculate source position to crop around the face
                    const sourceX = Math.max(0, faceData.x - (faceData.width * 0.3)); // Include some margin
                    const sourceY = Math.max(0, faceData.y - (faceData.height * 0.4)); // Include forehead
                    const sourceWidth = Math.min(img.width - sourceX, faceData.width * 1.6);
                    const sourceHeight = Math.min(img.height - sourceY, faceData.height * 1.8);
                    // Draw the aligned image
                    ctx.fillStyle = '#f0f0f0'; // Light gray background
                    ctx.fillRect(0, 0, outputSize, outputSize);
                    ctx.drawImage(img, sourceX, sourceY, sourceWidth, sourceHeight, targetX, targetY, scaledFaceWidth, scaledFaceHeight);
                    // Draw face detection overlay for debugging
                    if (faceData.eyeCenter) {
                        ctx.strokeStyle = '#00ff00';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(targetX, targetY, scaledFaceWidth, scaledFaceHeight);
                        // Draw eye center point
                        ctx.fillStyle = '#ff0000';
                        ctx.beginPath();
                        const eyeX = targetX + (faceData.eyeCenter.x - faceData.x) * scale;
                        const eyeY = targetY + (faceData.eyeCenter.y - faceData.y) * scale;
                        ctx.arc(eyeX, eyeY, 3, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                    resolve(canvas.toDataURL('image/jpeg', 0.9));
                }
                catch (error) {
                    reject(error);
                }
            };
            img.onerror = () => {
                reject(new Error('Failed to load image for alignment'));
            };
            img.src = imageUrl;
        });
    }
    /**
     * Get debug information about face detection
     */
    async getDebugInfo(imageUrl) {
        try {
            const detection = await this.faceDetectService.detectFacesFromUrl(imageUrl);
            return {
                imageUrl,
                detection,
                faces: detection.faces.map(face => ({
                    ...face,
                    area: face.width * face.height,
                    estimatedEyes: this.estimateEyeCenter(face)
                }))
            };
        }
        catch (error) {
            return {
                imageUrl,
                error: error instanceof Error ? error.message : 'Unknown error'
            };
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.14", ngImport: i0, type: FaceAlignmentService, deps: [{ token: FaceDetectService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.14", ngImport: i0, type: FaceAlignmentService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.14", ngImport: i0, type: FaceAlignmentService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: () => [{ type: FaceDetectService }] });

/*
 * Public API Surface of interest-comparator
 */

/**
 * Generated bundle index. Do not edit.
 */

export { FaceAlignmentService, FaceDetectService, InterestComparatorComponent, SimilarityService };
//# sourceMappingURL=interest-comparator.mjs.map
